Мы создаём приложение, которое поможет нам для массива диодов на адресной светодиодной ленте получить соответствие с расположением её диодов на равнопромежуточной азимутальной проекции большого полусферического купола.
Пользователю придётся провести калибровку при помощи камеры из нескольких фиксированных точек вокруг купола. И потом приложение должно отдавать файл, в котором будет эта калибровка.

### __Резюме проекта: "Калибровка светодиодного купола"__

__1. Исходная задача:__ Мы начали с задачи адаптации существующего приложения (GyverTwink) для калибровки расположения светодиодов на большом полусферическом куполе (высотой 4.2 метра). Цель — получить 2D-карту ("развертку") диодов для последующего наложения визуальных эффектов.

__2. Что было сделано (Эволюция и текущая реализация):__ В ходе обсуждения мы прошли несколько итераций и полностью переработали исходный механизм калибровки.

- __Отказ от 3D:__ Мы отказались от сложной 3D-реконструкции в пользу "сшивания" 2D-изображений, снятых с разных ракурсов.

- __Переход к быстрому сканированию:__ Чтобы решить проблему огромного времени калибровки (для ~5250 диодов), мы заменили последовательный перебор диодов на __быстрый алгоритм побитового сканирования__.

- __Обеспечение отказоустойчивости:__ Для защиты от ошибок в алгоритм встроены два механизма:

  1. __Двойное сканирование:__ Каждый бит проверяется дважды (прямой и инверсный проход).
  2. __Кластеризация:__ Анализируются только "стабильные" светлые пятна, присутствующие на всех кадрах.

- __Решение проблемы с UDP:__ Для отправки команд с большим количеством данных (списки диодов для зажигания) реализован механизм __разбивки одной большой команды на несколько маленьких пакетов (чанков)__.

__Итог:__ Проект был успешно и полностью переработан. Текущая версия содержит быстрый, надежный и сложный алгоритм калибровки, соответствующий всем поставленным требованиям.

---

### __Ключевая информация для нового ИИ-планировщика__

Эта информация критически важна для понимания проекта и отсутствует в исходном коде в явном виде.

1. __Физический контекст объекта:__

   - Это не маленький настольный прибор, а __стационарный купол высотой 4.2 метра__.
   - Пользовательский сценарий калибровки — это __съемка с нескольких (4-8) фиксированных позиций__ при помощи камеры на штативе, а не плавный обход с телефоном в руках.

2. __Протокол пакетной передачи данных:__

   - Для зажигания групп диодов используется команда с кодом `6`.
   - Поскольку список диодов может быть очень большим, он разбивается на пакеты (чанки) размером не более 512 ID в каждом.
   - __Формат пакета:__ `{[6], [cmdId_H], [cmdId_L], [total_chunks], [chunk_idx], [chunk_size_H], [chunk_size_L], [id1_H], [id1_L], ...}`.
   - Микроконтроллер должен накапливать данные из всех пакетов с одинаковым `commandId` и зажигать диоды только после получения последнего пакета (`chunk_idx == total_chunks - 1`).

3. __Суть алгоритма калибровки (в `func.pde`):__

   - Функция `scanCurrentView` — это "сердце" проекта.

   - Она выполняет __26 проходов__ для определения __13 бит__ ID диода (13 прямых + 13 инверсных).

   - __Ключевые шаги алгоритма:__

     1. Сбор координат всех ярких пятен за 26 проходов.
     2. __Кластеризация:__ Все точки со всех кадров группируются по пространственной близости. Это позволяет найти "стабильные" пятна, соответствующие реальным диодам.
     3. __Декодирование:__ Для каждого кластера (стабильного пятна) анализируется его "история" за 26 проходов. ID вычисляется только если для каждого бита точка была видна строго на одном из двух проходов (прямом или инверсном).
     4. Результат — карта `[ID диода] -> [координаты]`.

4. __Ключевые константы:__

   - Система настроена на `TOTAL_LEDS = 5250`.
   - Это определяет `BIT_COUNT = 13` и `PASS_COUNT = 26`. Если количество диодов изменится, эти константы нужно будет пересчитать.
