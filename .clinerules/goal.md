# Цель и архитектура проекта "Светодиодный купол"

Этот документ описывает ключевые архитектурные решения и технические детали проекта, который эволюционировал от утилиты для калибровки до полноценной платформы для генерации визуальных эффектов.

---

## Часть 1: Система калибровки

### 1.1. Задача
Основная цель — создать 2D-карту ("развертку") расположения ~5250 светодиодов на большом полусферическом куполе (высота 4.2м) для последующего наложения визуальных эффектов. Калибровка выполняется путем съемки с нескольких (4-8) фиксированных позиций камерой на штативе.

### 1.2. Ключевые архитектурные решения
- **Отказ от 3D-реконструкции:** Вместо сложного 3D-моделирования используется "сшивание" 2D-изображений, снятых с разных ракурсов.
- **Быстрое побитовое сканирование:** Для быстрой идентификации диодов вместо последовательного перебора используется алгоритм побитового сканирования. Это сокращает время калибровки с часов до минут.
- **Отказоустойчивость:**
  1. **Двойное сканирование:** Каждый бит ID диода проверяется дважды (прямой и инверсный проход), что повышает надежность.
  2. **Кластеризация:** Анализируются только "стабильные" светлые пятна, присутствующие на всех кадрах, что отсеивает шумы и артефакты.

### 1.3. Важные технические детали
- **Алгоритм калибровки (`func.pde` -> `scanCurrentView`):**
  - Выполняет 26 проходов для определения 13 бит ID диода.
  - **Шаги:** Сбор координат ярких пятен -> Кластеризация для поиска стабильных точек -> Декодирование ID на основе "истории" свечения каждого кластера.
- **Протокол пакетной передачи (Команда `6`):**
  - Для зажигания больших групп диодов используется команда, которая разбивает длинный список ID на чанки размером не более 512 ID.
  - **Формат пакета:** `{[6], [cmdId_H], [cmdId_L], [total_chunks], [chunk_idx], [chunk_size_H], [chunk_size_L], [id1_H], [id1_L], ...}`.
  - Микроконтроллер накапливает чанки и выполняет команду только после получения последнего.
- **Ключевые константы:** `TOTAL_LEDS = 5250`, `BIT_COUNT = 13`, `PASS_COUNT = 26`.

---

## Часть 2: Система визуальных эффектов "Ночное Солнце"

### 2.1. Задача
Создать платформу для генерации и отображения сложных, динамических визуальных эффектов (плазма, солнечные вспышки, градиенты) на поверхности купола с высокой производительностью (30-60 FPS).

### 2.2. Ключевые архитектурные решения
- **Генерация эффектов на клиенте (Android):** Вся логика эффектов выполняется на Android-устройстве с помощью **GLSL-шейдеров**. На микроконтроллер отправляется только готовый поток цветовых данных. Это снимает вычислительную нагрузку с контроллера.
- **Многослойный рендеринг (Multi-pass Rendering):** Различные эффекты (плазма, пятна, вспышки) рендерятся на отдельных `PGraphics` слоях, а затем смешиваются. Это обеспечивает гибкость и возможность комбинировать визуализации.
- **Машина состояний (`scenario.pde`):** Управляет жизненным циклом арт-объекта ("Восход", "Зенит", "Закат", "Сбой") и параметрами (uniforms) для шейдеров.

### 2.3. Важные технические детали
- **Проекция эффекта на купол (`func.pde` -> `sampleLedColors`):**
  - Это "сердце" системы визуализации. Алгоритм корректно "оборачивает" плоский 2D-эффект вокруг 3D-поверхности купола.
  - **Шаги:** Нахождение центра 2D-карты -> Вычисление полярных координат (угол, радиус) для каждого диода -> Преобразование в `(u, v)` координаты для сэмплирования с текстуры шейдера.
- **Протокол потоковой передачи (Команда `7`):**
  - Для отправки полного кадра цветов (~15.7 КБ) используется протокол с разбивкой на чанки.
- **Управление динамическими объектами (`scenario.pde`):**
  - Для каждого типа объектов (пятна, вспышки, петли) созданы свои классы (`SunSpot`, `Flare`) и менеджеры, управляющие их жизненным циклом и передачей данных в шейдеры.
- **Реализованные эффекты:**
  - **Фазы:** "Восход", "Закат" (волна света/тьмы).
  - **"Зенит":** Кипящая плазма, глобальное дыхание, солнечные пятна, вспышки и корональные петли.
  - **Событие:** "Киберпанк-сбой" с глитч-эффектами.

---

## Как добавить новый эффект

1.  **Создать шейдер:** Написать новый `.frag` файл в папке `data/`.
2.  **Добавить слой:** Инициализировать новый `PGraphics` холст в `GyverTwink.pde`.
3.  **Интегрировать рендеринг:** Добавить вызов рендеринга нового слоя в `draw()` в `GyverTwink.pde`.
4.  **Создать логику управления:** В `scenario.pde` создать класс и/или менеджер для управления жизненным циклом и параметрами нового эффекта.
5.  **Связать логику и рендеринг:** Передавать данные из `scenario.pde` в шейдер через `uniforms`.
